axios('http://localhost:3000/Banners',{method: "GET"}) // обращаемся к урлу, вторым параметром передаём конфик, в котором можем указать какие то параметры(например метод)
                .then((Banners) =>{
                    return Banners
                })
                .catch(console.log('error'))
/////////////////////////////////////////////////////////////////////////////
json-server - фейковый сервер с фейковой базой данных DateBody.json (json-server --watch db.json)
с помощью axios мы можем ,либо получить данные из БД ,либо отправить и изменить данные в БД
vuex - библиотека управления состоянием, в state мы можем поместить какие либо данные из БД, далее в самом приложение обращаться уже к state и брать оттуда какие нибудь данные, либо менять их
редактирование state осуществляется по средствам мутаций, 

//////////////////////////////////////////////////////////////////////////////////
наследование: у дочерних элемнтов будут сохраняться свойства родительского
//////////////////////////////////////////////////////////////////////////////////
var - блочная обл. видимости, let - функциональная обл. видимости
//////////////////////////////////////////////////////////////////////////////////
замыкание - переменные обьявленные в функции останутся в ней, после отработки функции они удалятся
//////////////////////////////////////////////////////////////////////////////////
console.log('start')
const btn = document.getElementById('btn')

function someFunction() {
    setTimeout(function callback() {
        console.log('ВНУТРИТАЙМАУТА')
    }, 3000)

    console.log('внутри someFunction')
}

btn.addEventListener('click', someFunction)

someFunction()

console.log('end')

Всё идёт в call stack
1. Выполняется console.log('start')
2. Выполняется поиск элемнета по id
3. Вешаем слушатель события на элемент --> Слушатель события отправляется в WEB Api
4. Вызов функции someFunction()
5. Функция за счёт setTimeout переходит в WEB Api и там начинается отсчёт
6. Выполняется console.log('внутри someFunction')
7. console.log('end') попадает в стек вызовов (отсчёт всё еще идёт),
Допустим, что, пользователь решил нажать на кнопку,
someFunction попадает в очередь задач (CallBack queue),
до тех пор пока стек вызовов (Call stack) не будет пустым,
в этот момент заканчивается таймер и callback попадает в очередь задач
8. Выполняется console.log('end')
9. В Стек вызовов попадает функция вызванная при клике пользователем
сразу же начинается п.5, п.6
10. Из очереди задач в стек вызовов попадает callback который был вызван в первый раз
11. Выполняется console.log('ВНУТРИТАЙМАУТА')
12. Далее в очередь задач попадает второй callback, если стек вызовов очистился,
тогда callback попадает в него далее п.11